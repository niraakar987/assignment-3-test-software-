# assignment-3-test-software-

This project is a simple Requisition System that I built using Python. The idea behind it is to let staff members request items they need, and the system keeps track of those requests. A manager or admin can then approve or reject the requisitions depending on how much they cost. While writing the code, I tried to keep some basic programming design principles in mind, such as KISS (Keep It Simple, Stupid), DRY (Don’t Repeat Yourself), and the Single Responsibility Principle. These principles assist in developing a well-structured and maintainable system. For example, the function get_requisition_items() follows SRP by entirely handling the collection of item details, using a simple while loop to collect item names and prices. This method also sticks to KISS, as the logic is easy, using "done" to end the input process and avoid unnecessary complication. The function is efficient and easy to understand. However, the method requisitions_total() combines two responsibilities: collecting requisition data and calculating the total. While functional, this violates SRP, as it does too much. Splitting this method into two would increase clarity and maintainability., likewise, DRY is followed in the requisition_approval() function, where the approval reference is generated consistently and reused. This prevents the need to duplicate logic for formatting the approval reference in multiple places. Another example of DRY is the use of Python’s built-in sum() function in requisitions_total() to calculate the total price of items, which is both concise and avoids manual iteration over the list. However, a global counter is used in the code to generate requisition IDs, which violates encapsulation. This global state can be modified from anywhere in the program, which makes tracking changes difficult and error-prone. A better approach would be to encapsulate the counter within the class RequisitionSystem, making it a class attribute to prevent potential conflicts and to attach more closely to SRP by avoiding the use of global variables. The staff_info() function, which collects basic requisition details such as staff ID, name, and requisition ID, could also benefit from a similar refactor by encapsulating the requisition ID generation within the class, rather than relying on a global counter. The system’s methods generally follow SRP, but there are areas for improvement. For example, the method respond_requisition() handles both updating the requisition and adjusting counters for approval and non-approval statuses. This can be split into smaller, more focused functions to better follow SRP. Similarly, the create_requisition() function is responsible for several tasks: collecting data, approving requisitions, and storing requisition objects. Again, separating these tasks would improve the code’s modularity and adherence to SRP. On the other hand, methods like display_requisitions() and requisition_statistics() effectively bond to SRP, as they are focused completely on displaying information. These methods are clear and simple, making them easy to maintain. In conclusion, the code is generally well-structured and follows the key design principles of SRP, KISS, and DRY, though some functions could be refactored to better adhere to these principles. By improving the separation of concerns—such as splitting larger methods like requisitions_total() into smaller methods co encapsulating the global counter into the class—the system would be easier to maintain and extend in the future. The overall design is a solid example of applying basic software design principles to a real-world problem, ensuring the system is clear, efficient, and flexible for future changes.


